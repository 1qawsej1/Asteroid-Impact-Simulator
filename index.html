<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asteroid Impact Simulator — 3D Globe</title>

  <!-- Roboto font -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

  <!-- CesiumJS CSS -->
  <link href="https://unpkg.com/cesium@latest/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

  <!-- SheetJS for Excel/CSV parsing -->
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    @import url(../templates/bucket.css);
    :root {
      --bg: #0f1724;
      --card: #0b1220;
      --accent: #7c3aed;
      --muted: #94a3b8;
      --glass: rgba(255,255,255,0.03);
      font-family: 'Roboto', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
    }
    * {
      box-sizing: border-box;
    }
    html, body, #cesiumContainer {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      height: 100vh;
      display: flex;
      background: linear-gradient(180deg, #071026 0%, #081426 60%);
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
    }
    .app {
      display: flex;
      gap: 18px;
      width: 100%;
      padding: 18px;
      box-sizing: border-box;
      overflow: hidden;
    }
    .left {
      flex: 1;
      min-width: 320px;
      max-width: 860px;
      height: calc(100vh - 36px);
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      position: relative;
    }
    #cesiumContainer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #cesiumContainer .cesium-viewer {
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: 100% !important;
      height: 100% !important;
    }
    #cesiumContainer canvas {
      width: 100% !important;
      height: 100% !important;
      display: block !important;
    }
    .right {
      width: 420px;
      max-width: 40%;
      min-width: 280px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow-y: auto;
      height: calc(100vh - 36px);
      -webkit-overflow-scrolling: touch;
    }
    .card {
      background: var(--card);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.6);
      flex-shrink: 0;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-in-out;
    }
    .controls.visible {
      max-height: none;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      position: relative;
    }
    .row:hover .tooltip {
      display: block;
    }
    .tooltip {
      display: none;
      position: absolute;
      top: -40px;
      left: 0;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      z-index: 1000;
      max-width: 200px;
    }
    .label {
      min-width: 88px;
      font-size: 13px;
      color: var(--muted);
      flex-shrink: 0;
      font-weight: 500;
    }
    .value {
      font-weight: 600;
      min-width: 90px;
      text-align: right;
      flex-shrink: 0;
    }
    input[type=range], input[type=text] {
      width: 100%;
      max-width: 200px;
      padding: 6px;
      border-radius: 6px;
      background: var(--glass);
      color: inherit;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .outputs {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .output {
      background: var(--glass);
      padding: 10px;
      border-radius: 10px;
      font-size: 13px;
      position: relative;
    }
    .output:hover .tooltip {
      display: block;
    }
    .output strong {
      width: 180px;
      display: inline-block;
    }
    .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      background: linear-gradient(180deg, var(--accent), #5b21b6);
      border: none;
      color: white;
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(92,33,182,0.18);
      flex: 1;
      min-width: 100px;
    }
    button.secondary {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: none;
      color: var(--muted);
    }
    .toggle-btn {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 16px;
      cursor: pointer;
      padding: 0 8px;
    }
    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .legend .sw {
      width: 18px;
      height: 10px;
      border-radius: 4px;
    }
    .sw.red {
      background: linear-gradient(90deg, rgba(255,69,58,0.95), rgba(255,86,86,0.6));
    }
    .sw.orange {
      background: linear-gradient(90deg, #ff8a00, #ffb86b);
    }
    .sw.yellow {
      background: linear-gradient(90deg, #ffd54a, #fff59d);
    }
    .sw.mild {
      background: linear-gradient(90deg, #c8f7a6, #e6ffcf);
    }
    .sw.blue {
      background: linear-gradient(90deg, #1e90ff, #87cefa);
    }
    @media (max-width: 920px) {
      .app {
        flex-direction: column;
        padding: 10px;
        gap: 10px;
      }
      .left {
        max-width: none;
        height: 60vh;
        min-height: 300px;
      }
      .right {
        width: 100%;
        max-width: none;
        height: auto;
        overflow-y: visible;
        gap: 10px;
      }
      .card {
        padding: 10px;
      }
      .output strong {
        width: 140px;
      }
      .row {
        gap: 8px;
      }
      .label {
        min-width: 70px;
      }
      .value {
        min-width: 60px;
      }
      .tooltip {
        max-width: 100%;
      }
      input[type=range], input[type=text] {
        max-width: 100%;
      }
      .buttons {
        justify-content: space-between;
      }
      button {
        flex: none;
        min-width: auto;
        padding: 8px 12px;
        font-size: 14px;
      }
      .toggle-btn {
        display: none;
      }
    }
    @media (max-width: 480px) {
      .app {
        padding: 8px;
      }
      .left {
        height: 50vh;
      }
      .output strong {
        width: 100%;
        display: block;
        margin-bottom: 4px;
      }
      .output {
        padding: 8px;
        font-size: 12px;
      }
      .legend {
        justify-content: center;
      }
    }
    .tooltip-content {
      font-size: 13px;
    }
    .fall-wrap {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
      overflow: visible;
      z-index: 600;
    }
    .fall {
      position: absolute;
      font-size: 36px;
      transform: translate(-50%, -50%);
      opacity: 0;
    }
    .muted-small {
      font-size: 12px;
      color: var(--muted);
    }
    #loadingOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 1000;
    }
    #toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 500;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="left card">
      <div id="cesiumContainer" class="fullSize"></div>
      <div class="fall-wrap" id="fallWrap" aria-hidden="true"></div>
      <div id="loadingOverlay">
        <h1>Loading...</h1>
      </div>
      <div id="toolbar"></div>
    </div>
    <div class="right">
      <div class="card">
        <div style="display: flex; justify-content: space-between; align-items: center; margin: 6px 0 10px 0">
          <h3 style="margin: 0">Asteroid Impact Simulator</h3>
          <button id="toggleControls" class="toggle-btn">▼</button>
        </div>
        <div class="controls" id="controls">
          <div class="row">
            <div class="label">Cesium Ion Token</div>
            <div style="flex:1"><input id="ionToken" type="text" placeholder="Enter Cesium Ion Token"></div>
            <div class="tooltip">Access token for Cesium 3D tiles (optional for buildings).</div>
          </div>
          <div class="row">
            <div class="label">Mass (kg)</div>
            <div style="flex:1"><input id="massRange" type="range" min="1e6" max="1e13" step="1" value="1e9"></div>
            <div class="value" id="massVal">1,000,000,000</div>
            <div class="tooltip">Asteroid mass, affecting impact energy.</div>
          </div>
          <div class="row">
            <div class="label">Speed (m/s)</div>
            <div style="flex:1"><input id="speedRange" type="range" min="5000" max="50000" step="100" value="20000"></div>
            <div class="value" id="speedVal">20,000</div>
            <div class="tooltip">Velocity relative to Earth, in meters per second.</div>
          </div>
          <div class="row">
            <div class="label">Angle (°)</div>
            <div style="flex:1"><input id="angleRange" type="range" min="0" max="90" step="1" value="45"></div>
            <div class="value" id="angleVal">45°</div>
            <div class="tooltip">Impact angle from vertical; affects crater size.</div>
          </div>
          <div class="row">
            <div class="label">Density (kg/m³)</div>
            <div style="flex:1"><input id="densityRange" type="range" min="1000" max="8000" step="100" value="3000"></div>
            <div class="value" id="densityVal">3,000</div>
            <div class="tooltip">Material density, e.g., 3000 for rocky asteroids.</div>
          </div>
          <div class="row">
            <div class="label">Latitude</div>
            <div style="flex:1"><input id="latRange" type="range" min="-90" max="90" step="0.0001" value="0"></div>
            <div class="value" id="latVal">0.0000°</div>
            <div class="tooltip">Impact latitude; click globe to set.</div>
          </div>
          <div class="row">
            <div class="label">Longitude</div>
            <div style="flex:1"><input id="lngRange" type="range" min="-180" max="180" step="0.0001" value="0"></div>
            <div class="value" id="lngVal">0.0000°</div>
            <div class="tooltip">Impact longitude; click globe to set.</div>
          </div>
          <div class="row">
            <div class="label">Deflect Δv (m/s)</div>
            <div style="flex:1"><input id="deflectRange" type="range" min="0" max="1000" step="10" value="0"></div>
            <div class="value" id="deflectVal">0</div>
            <div class="tooltip">Velocity change from mitigation (e.g., kinetic impactor).</div>
          </div>
          <div class="row">
            <div class="label">Fragment (%)</div>
            <div style="flex:1"><input id="fragRange" type="range" min="0" max="90" step="1" value="0"></div>
            <div class="value" id="fragVal">0%</div>
            <div class="tooltip">Mass lost to fragmentation in atmosphere.</div>
          </div>
          <div class="buttons" style="margin-top:6px">
            <button id="simulateBtn">Simulate Impact</button>
            <button id="defendBtn">Defend Earth</button>
            <button id="resetBtn" class="secondary">Reset</button>
            <button id="animateBtn" class="secondary">Animate Fall</button>
            <button id="impactor2025Btn" class="secondary">Impactor-2025</button>
          </div>
        </div>
      </div>
      <div class="card">
        <h3 style="margin:6px 0 10px 0">NASA NEO Integration</h3>
        <button id="fetchNeoBtn">Fetch Upcoming NEOs</button>
        <select id="neoSelect" style="width:100%; margin-top:10px; padding:6px; border-radius:6px; background:var(--glass); color:inherit; border:1px solid rgba(255,255,255,0.06);">
          <option value="">Select NEO</option>
        </select>
        <div class="muted-small" style="margin-top:8px">Fetches near-Earth objects from NASA's API. Select one to auto-set mass, speed, and density based on real data (hypothetical impact).</div>
      </div>
      <div class="card outputs">
        <div class="output"><strong>Asteroid diameter:</strong> <span id="astDia">—</span> m<div class="tooltip">Estimated diameter based on mass and density.</div></div>
        <div class="output"><strong>Kinetic energy:</strong> <span id="keVal">—</span> J (<span id="keSci">—</span>)<div class="tooltip">Energy of impact, compared to TNT equivalent.</div></div>
        <div class="output"><strong>Airburst altitude:</strong> <span id="airburstVal">—</span> km<div class="tooltip">Altitude where small asteroids disintegrate.</div></div>
        <div class="output"><strong>Crater diameter:</strong> <span id="craterVal">—</span> km<div class="tooltip">Size of impact crater, based on energy.</div></div>
        <div class="output"><strong>Blast radii (Severe/Heavy/Mod/Mild):</strong> <span id="radiiVal">—</span> km<div class="tooltip">Damage zones from blast wave.</div></div>
        <div class="output"><strong>Thermal radiation radius:</strong> <span id="thermalVal">—</span> km<div class="tooltip">Area affected by heat from impact.</div></div>
        <div class="output"><strong>Seismic magnitude:</strong> <span id="seismicVal">—</span><div class="tooltip">Earthquake strength from impact, adjusted for seismic zone.</div></div>
        <div class="output"><strong>Tsunami risk:</strong> <span id="tsunamiVal">—</span><div class="tooltip">Likelihood of tsunami if impact is in ocean.</div></div>
        <div class="output"><strong>Affected population:</strong> <span id="popAffected">—</span><div class="tooltip">Estimated people in blast zones.</div></div>
        <div class="output"><strong>Estimated fatalities:</strong> <span id="fatalitiesVal">—</span><div class="tooltip">Estimated deaths based on blast severity.</div></div>
        <div class="output" id="warningBox" style="display:none;background:linear-gradient(90deg,#3b0832, #6b1b43);color:#fff">⚠️ <span id="warningText"></span></div>
        <div class="muted-small" id="popNote">Population estimated using country-average density. Click the globe to simulate and fetch local country data.</div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
          <div class="legend">
            <div class="sw red"></div><div style="font-size:13px;color:var(--muted);">Severe</div>
            <div class="sw orange" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Heavy</div>
            <div class="sw yellow" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Moderate</div>
            <div class="sw mild" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Mild</div>
            <div class="sw blue" style="margin-left:8px"></div><div style="font-size:13px;color:var(--muted);">Tsunami</div>
          </div>
        </div>
      </div>
      <div class="card" style="text-align:center;font-size:13px;color:var(--muted)">
        Tip: drag sliders — simulation updates instantly. Click/rotate/zoom the globe to explore. Try "Defend Earth" to test mitigation!
      </div>
    </div>
  </div>

  <!-- CesiumJS with primary and fallback CDN -->
  <script src="https://unpkg.com/cesium@latest/Build/Cesium/Cesium.js"></script>
  <script>
    // Fallback for CesiumJS if primary CDN fails
    if (typeof Cesium === 'undefined') {
      document.write('<script src="https://cdn.jsdelivr.net/npm/cesium@latest/Build/Cesium/Cesium.js"><\/script>');
    }
  </script>

  <script>
    // Web Worker for heavy calculations
    const worker = new Worker(URL.createObjectURL(new Blob([`
      self.onmessage = function(e) {
        const { mass, speed, angle, density, deflect } = e.data;
        function computeAsteroidDiameter(massKg, density) {
          const vol = massKg / density;
          const radius = Math.cbrt((3 * vol) / (4 * Math.PI));
          return 2 * radius;
        }
        function computeKE(massKg, speedMs) {
          return 0.5 * massKg * speedMs * speedMs;
        }
        function estimateCraterDiameterKm(keJ, angleDeg) {
          const angleFactor = Math.sin(angleDeg * Math.PI / 180);
          const effectiveKE = keJ * angleFactor;
          const C = 0.2;
          const D_m = C * Math.pow(effectiveKE, 0.25);
          return D_m / 1000;
        }
        function estimateAirburstAltitude(diameter_m, speedMs, angleDeg, density) {
          const baseAltitude = 50;
          const sizeFactor = Math.min(25 / diameter_m, 2);
          const speedFactor = Math.min(12000 / speedMs, 1.5);
          const angleFactor = angleDeg / 90;
          const densityFactor = Math.min(2000 / density, 1.5);
          const altitude = baseAltitude * (0.5 * sizeFactor + 0.3 * speedFactor + 0.1 * angleFactor + 0.1 * densityFactor);
          return Math.min(Math.max(altitude, 10), 100);
        }
        function estimateThermalRadiusKm(keJ) {
          const C_thermal = 0.05;
          const R_m = C_thermal * Math.pow(keJ, 1/3);
          return R_m / 1000;
        }
        function estimateSeismicMagnitude(keJ, seismicZoneFactor) {
          const logE = Math.log10(keJ);
          const M = (logE - 4.8) / 1.5;
          return Math.max(0, Math.min(M * seismicZoneFactor, 12));
        }
        function checkAtmosphericDisintegration(diameter_m, speedMs, angleDeg, density) {
          return (
            diameter_m < 25 &&
            (angleDeg > 60 || speedMs < 12000 || density < 2000)
          );
        }
        const effectiveSpeed = speed * (1 - deflect / 1000);
        const effectiveMass = mass;
        const diameter_m = computeAsteroidDiameter(effectiveMass, density);
        const ke = computeKE(effectiveMass, effectiveSpeed);
        const disintegrates = checkAtmosphericDisintegration(diameter_m, effectiveSpeed, angle, density);
        let result;
        if (disintegrates) {
          const airburst_km = estimateAirburstAltitude(diameter_m, effectiveSpeed, angle, density);
          result = {
            diameter_m, ke, airburst_km, crater_km: 0, severe_km: 0, heavy_km: 0,
            moderate_km: 0, mild_km: 0, thermal_km: 0, seismic_mag: 0, disintegrates: true
          };
        } else {
          const crater_km = estimateCraterDiameterKm(ke, angle);
          const severe_km = Math.max(0.5, crater_km * 0.6);
          const heavy_km = Math.max(severe_km * 1.8, crater_km * 2.0);
          const moderate_km = Math.max(heavy_km * 1.9, crater_km * 5.0);
          const mild_km = Math.max(moderate_km * 2.2, crater_km * 12.0);
          const thermal_km = estimateThermalRadiusKm(ke);
          const seismic_mag = estimateSeismicMagnitude(ke, 1); // Default seismic factor
          result = {
            diameter_m, ke, airburst_km: 0, crater_km, severe_km, heavy_km,
            moderate_km, mild_km, thermal_km, seismic_mag, disintegrates: false
          };
        }
        self.postMessage(result);
      };
    `], { type: 'text/javascript' })));

    // Excel/CSV handling
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error('Excel parsing error:', e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }

    document.addEventListener('DOMContentLoaded', async () => {
      if (typeof Cesium === 'undefined') {
        console.error('CesiumJS failed to load. Please check CDN links or network connection.');
        const warnBox = document.getElementById('warningBox');
        const warnText = document.getElementById('warningText');
        warnBox.style.display = 'block';
        warnText.textContent = 'Error: CesiumJS library failed to load. Please refresh the page or check your network.';
        return;
      }

      // --- Toggle Controls with Dynamic Height ---
      const toggleBtn = document.getElementById('toggleControls');
      const controls = document.getElementById('controls');
      function toggleControls() {
        if (controls.classList.contains('visible')) {
          controls.classList.remove('visible');
          toggleBtn.textContent = '▶';
        } else {
          controls.classList.add('visible');
          toggleBtn.textContent = '▼';
        }
      }
      toggleBtn.addEventListener('click', toggleControls);

      // Detect mobile and auto-show controls
      if (window.innerWidth <= 920) {
        controls.classList.add('visible');
        toggleBtn.style.display = 'none';
        controls.style.maxHeight = 'none';
      } else {
        controls.classList.add('visible');
        toggleBtn.textContent = '▼';
      }

      // --- CesiumJS Setup ---
      async function initializeViewer() {
        const ionTokenInput = document.getElementById('ionToken');
        const ionToken = ionTokenInput.value || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJjOTJhOWYwZi1mNzc5LTQ0YzktYjVmMi00MDZiYjQ2ZmE5NmUiLCJpZCI6MzQ3MjcwLCJpYXQiOjE3NTk2MTg0MDd9.5lX_hVUnKo70VaAzshOrf4Zj5nqCNmpuVZ48VEDMAVY';
        if (ionToken) {
          Cesium.Ion.defaultAccessToken = ionToken;
          console.log('Using Cesium Ion Token:', ionToken);
        } else {
          console.warn('No Cesium Ion token provided. 3D tileset will not be loaded.');
          const warnBox = document.getElementById('warningBox');
          const warnText = document.getElementById('warningText');
          warnBox.style.display = 'block';
          warnText.textContent = 'No Cesium Ion token provided. 3D buildings tileset will not be loaded.';
        }

        const viewer = new Cesium.Viewer('cesiumContainer', {
          baseLayerPicker: false,
          geocoder: false,
          homeButton: false,
          sceneModePicker: false,
          navigationHelpButton: false,
          animation: false,
          timeline: false,
          fullscreenButton: false,
          vrButton: false,
          infoBox: false,
          selectionIndicator: false,
          sceneMode: Cesium.SceneMode.SCENE3D,
        });

        const container = viewer.container;
        const canvas = viewer.scene.canvas;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        viewer.resize();
        viewer.scene.requestRender();

        const loadingOverlay = document.getElementById('loadingOverlay');
        loadingOverlay.style.display = 'none';

        viewer.scene.screenSpaceCameraController.maximumZoomDistance = 25000000;
        viewer.scene.screenSpaceCameraController.minimumZoomDistance = 1000;
        viewer.scene.screenSpaceCameraController.enableTilt = false;

        const initialZoomHeight = window.innerWidth <= 920 ? 10000000 : 20000000;
        viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(0, 0, initialZoomHeight),
          orientation: {
            heading: Cesium.Math.toRadians(0),
            pitch: Cesium.Math.toRadians(-90),
            roll: 0
          }
        });

        viewer.scene.globe.enableLighting = true;

        if (ionToken) {
          try {
            console.log('Attempting to load 3D tileset (ID: 3830185)...');
            const tileset = await viewer.scene.primitives.add(
              await Cesium.Cesium3DTileset.fromIonAssetId(3830185)
            );
            tileset.maximumScreenSpaceError = 16;
            console.log('3D tileset loaded successfully.');
            viewer.resize();
            viewer.scene.requestRender();
          } catch (e) {
            console.error('Failed to load 3D tileset:', e);
            const warnBox = document.getElementById('warningBox');
            const warnText = document.getElementById('warningText');
            warnBox.style.display = 'block';
            warnText.textContent = 'Failed to load 3D buildings tileset. Using base map only.';
          }
        }

        function syncCanvasSize() {
          const rect = container.getBoundingClientRect();
          if (canvas.width !== rect.width || canvas.height !== rect.height) {
            console.log(`Resizing canvas: ${canvas.width}x${canvas.height} -> ${rect.width}x${rect.height}`);
            canvas.width = rect.width;
            canvas.height = rect.height;
            viewer.resize();
            viewer.scene.requestRender();
          }
          requestAnimationFrame(syncCanvasSize);
        }
        requestAnimationFrame(syncCanvasSize);

        viewer.camera.moveEnd.addEventListener(() => {
          const cartographic = viewer.camera.positionCartographic;
          const height = cartographic.height;
          if (height > 20000000) {
            viewer.camera.setView({
              destination: Cesium.Cartesian3.fromDegrees(0, 0, Math.min(height, 25000000)),
              orientation: {
                heading: Cesium.Math.toRadians(0),
                pitch: Cesium.Math.toRadians(-90),
                roll: 0
              }
            });
            viewer.scene.requestRender();
          }
        });

        return viewer;
      }

      const viewer = await initializeViewer();
      const impactEntities = [];
      let trajectoryEntity = null;
      let deflectedTrajectoryEntity = null;

      window.addEventListener('resize', () => {
        const container = viewer.container;
        const canvas = viewer.scene.canvas;
        const rect = container.getBoundingClientRect();
        if (canvas.width !== rect.width || canvas.height !== rect.height) {
          console.log(`Window resize: Canvas ${canvas.width}x${canvas.height} -> Container ${rect.width}x${rect.height}`);
          canvas.width = rect.width;
          canvas.height = rect.height;
          viewer.resize();
          viewer.scene.requestRender();
        }
        if (window.innerWidth <= 920 && !controls.classList.contains('visible')) {
          controls.classList.add('visible');
        }
      });

      // --- Utilities ---
      const $ = id => document.getElementById(id);
      const fmt = (v) => Number(v).toLocaleString();
      const fmtFixed = (v, n=2) => Number(v).toLocaleString(undefined, {maximumFractionDigits: n});
      const fmtSci = (v) => {
        if (!isFinite(v)) return '—';
        const abs = Math.abs(v);
        if (abs === 0) return '0';
        if (abs < 1e3 || abs > 1e8) return v.toExponential(3);
        return v.toLocaleString();
      };

      function debounce(fn, wait=120) {
        let t;
        return function(...args) {
          clearTimeout(t);
          t = setTimeout(() => fn.apply(this, args), wait);
        };
      }

      // --- DOM Elements ---
      const massR = $('massRange'), massV = $('massVal');
      const speedR = $('speedRange'), speedV = $('speedVal');
      const angleR = $('angleRange'), angleV = $('angleVal');
      const densityR = $('densityRange'), densityV = $('densityVal');
      const latR = $('latRange'), latV = $('latVal');
      const lngR = $('lngRange'), lngV = $('lngVal');
      const defR = $('deflectRange'), defV = $('deflectVal');
      const fragR = $('fragRange'), fragV = $('fragVal');
      const astDiaEl = $('astDia'), keValEl = $('keVal'), keSciEl = $('keSci');
      const airburstEl = $('airburstVal'), craterEl = $('craterVal'), radiiEl = $('radiiVal');
      const thermalEl = $('thermalVal'), seismicEl = $('seismicVal'), tsunamiEl = $('tsunamiVal');
      const popAffectedEl = $('popAffected'), fatalitiesEl = $('fatalitiesVal');
      const warnBox = $('warningBox'), warnText = $('warningText');
      const popNote = $('popNote');

      function updateDisplays() {
        massV.textContent = fmt(massR.value);
        speedV.textContent = fmt(speedR.value);
        angleV.textContent = fmt(angleR.value) + '°';
        densityV.textContent = fmt(densityR.value);
        latV.textContent = Number(latR.value).toFixed(4) + '°';
        lngV.textContent = Number(lngR.value).toFixed(4) + '°';
        defV.textContent = fmt(defR.value);
        fragV.textContent = fragR.value + '%';
      }
      [massR, speedR, angleR, densityR, latR, lngR, defR, fragR].forEach(el => el.addEventListener('input', updateDisplays));
      updateDisplays();

      // --- USGS Data Integration ---
      async function fetchUSGSElevation(lat, lng) {
        try {
          const url = `https://epqs.nationalmap.gov/v1/json?x=${encodeURIComponent(lng)}&y=${encodeURIComponent(lat)}&units=Meters&output=json`;
          const res = await fetch(url);
          if (!res.ok) throw new Error('USGS elevation fetch failed');
          const data = await res.json();
          return data.value || 0; // Elevation in meters
        } catch (e) {
          console.warn('USGS elevation fetch error:', e);
          return 0;
        }
      }

      async function fetchUSGSSeismicZone(lat, lng) {
        try {
          const url = `https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lng)}&maxradiuskm=100`;
          const res = await fetch(url);
          if (!res.ok) throw new Error('USGS seismic zone fetch failed');
          const data = await res.json();
          const seismicActivity = data.features.length > 0 ? 1.2 : 1.0; // Increase magnitude in active zones
          return seismicActivity;
        } catch (e) {
          console.warn('USGS seismic zone fetch error:', e);
          return 1.0; // Default factor
        }
      }

      async function estimateTsunamiRisk(lat, lng, elevation, ke) {
        if (elevation >= 0) return { risk: 'None', waveHeight: 0 };
        const distanceToCoast = await estimateDistanceToCoast(lat, lng);
        const keMt = ke / 4.184e15; // Megatons TNT
        const waveHeight = keMt > 10 ? Math.min(keMt * 0.1, 50) : 0; // Simplified: 0.1m per megaton, capped at 50m
        if (distanceToCoast < 100 && waveHeight > 0) {
          return { risk: 'High', waveHeight: waveHeight.toFixed(1) };
        } else if (distanceToCoast < 500 && waveHeight > 0) {
          return { risk: 'Moderate', waveHeight: waveHeight.toFixed(1) };
        }
        return { risk: 'Low', waveHeight: 0 };
      }

      async function estimateDistanceToCoast(lat, lng) {
        try {
          const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&zoom=10&addressdetails=1`;
          const res = await fetch(url);
          if (!res.ok) throw new Error('Coast distance fetch failed');
          const data = await res.json();
          return data.address && data.address.coastline ? 10 : 500; // Simplified: assume near coast if tagged
        } catch (e) {
          console.warn('Coast distance fetch error:', e);
          return 500; // Default far from coast
        }
      }

      // --- Physics (Moved to Worker) ---
      function computeImpact(massKg, speedMs, angleDeg, density, deflect, seismicZoneFactor, callback) {
        worker.onmessage = (e) => {
          callback(e.data);
        };
        worker.postMessage({ mass: massKg, speed: speedMs, angle: angleDeg, density, deflect });
      }

      // --- Population Estimation ---
      async function reverseGeocodeCountry(lat, lng) {
        try {
          const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}&zoom=3&addressdetails=1`;
          const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
          if (!res.ok) throw new Error('reverse geocode failed');
          const data = await res.json();
          const countryCode = data && data.address && data.address.country_code ? data.address.country_code.toUpperCase() : null;
          return countryCode;
        } catch (e) {
          console.warn('reverse geocode error', e);
          return null;
        }
      }

      async function fetchCountryDensity(alpha2) {
        try {
          const url = `https://restcountries.com/v3.1/alpha/${alpha2}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error('country fetch failed');
          const data = await res.json();
          const info = Array.isArray(data) ? data[0] : data;
          if (!info || !info.population || !info.area) return null;
          const density = info.population / info.area;
          return { density, population: info.population, area: info.area, name: info.name && info.name.common };
        } catch (e) {
          console.warn('country fetch error', e);
          return null;
        }
      }

      function ringAreas(severe_km, heavy_km, moderate_km, mild_km) {
        const area = (r) => Math.PI * r * r;
        const A_severe = area(severe_km);
        const A_heavy = Math.max(0, area(heavy_km) - A_severe);
        const A_moderate = Math.max(0, area(moderate_km) - area(heavy_km));
        const A_mild = Math.max(0, area(mild_km) - area(moderate_km));
        return { A_severe, A_heavy, A_moderate, A_mild };
      }

      async function estimatePopulationImpact(lat, lng, result) {
        if (result.disintegrates) {
          return { densityData: null, density: 0, perZone: {}, totalAffected: 0, totalFatal: 0 };
        }
        const fallbackDensity = 60;
        const countryCode = await reverseGeocodeCountry(lat, lng);
        let densityData = null;
        if (countryCode) {
          densityData = await fetchCountryDensity(countryCode).catch(() => null);
        }
        const density = densityData && densityData.density ? densityData.density : fallbackDensity;
        const areas = ringAreas(result.severe_km, result.heavy_km, result.moderate_km, result.mild_km);
        const pop_severe = areas.A_severe * density;
        const pop_heavy = areas.A_heavy * density;
        const pop_moderate = areas.A_moderate * density;
        const pop_mild = areas.A_mild * density;
        const totalAffected = pop_severe + pop_heavy + pop_moderate + pop_mild;
        const fatal_severe = pop_severe * 0.9;
        const fatal_heavy = pop_heavy * 0.5;
        const fatal_moderate = pop_moderate * 0.15;
        const fatal_mild = pop_mild * 0.02;
        const totalFatal = fatal_severe + fatal_heavy + fatal_moderate + fatal_mild;
        return {
          densityData,
          density,
          perZone: {
            severe: { area_km2: areas.A_severe, pop: pop_severe, fatal: fatal_severe },
            heavy: { area_km2: areas.A_heavy, pop: pop_heavy, fatal: fatal_heavy },
            moderate: { area_km2: areas.A_moderate, pop: pop_moderate, fatal: fatal_moderate },
            mild: { area_km2: areas.A_mild, pop: pop_mild, fatal: fatal_mild }
          },
          totalAffected, totalFatal
        };
      }

      // --- Interaction: Draw on Globe ---
      function clearImpact() {
        impactEntities.forEach(entity => viewer.entities.remove(entity));
        impactEntities.length = 0;
        if (trajectoryEntity) {
          viewer.entities.remove(trajectoryEntity);
          trajectoryEntity = null;
        }
        if (deflectedTrajectoryEntity) {
          viewer.entities.remove(deflectedTrajectoryEntity);
          deflectedTrajectoryEntity = null;
        }
        warnBox.style.display = 'none';
        astDiaEl.textContent = '—';
        keValEl.textContent = '—';
        keSciEl.textContent = '—';
        airburstEl.textContent = '—';
        craterEl.textContent = '—';
        radiiEl.textContent = '—';
        thermalEl.textContent = '—';
        seismicEl.textContent = '—';
        tsunamiEl.textContent = '—';
        popAffectedEl.textContent = '—';
        fatalitiesEl.textContent = '—';
        popNote.textContent = 'Population estimated using country-average density. Click the globe to simulate and fetch local country data.';
        viewer.scene.requestRender();
      }

      function createEllipse(lng, lat, radius_km, color, opacity, label) {
        const radius_m = radius_km * 1000;
        const entity = viewer.entities.add({
          position: Cesium.Cartesian3.fromDegrees(lng, lat),
          ellipse: {
            semiMajorAxis: radius_m,
            semiMinorAxis: radius_m,
            material: Cesium.Color.fromCssColorString(color).withAlpha(opacity),
            outline: false
          },
          label: {
            text: `${label}: ${fmtFixed(radius_km, 2)} km`,
            font: '13px Roboto, sans-serif',
            fillColor: Cesium.Color.WHITE,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            pixelOffset: new Cesium.Cartesian2(0, -20),
            show: false
          }
        });
        return entity;
      }

      async function drawImpact(lat, lng, result, elevation, tsunamiRisk) {
        clearImpact();
        if (result.disintegrates) {
          warnBox.style.display = 'block';
          warnText.textContent = `Meteor disintegrates in atmosphere at ~${fmtFixed(result.airburst_km, 1)} km altitude — no ground impact.`;
          astDiaEl.textContent = fmtFixed(result.diameter_m, 1);
          keValEl.textContent = fmt(parseFloat(result.ke.toFixed(0)));
          keSciEl.textContent = fmtSci(result.ke);
          airburstEl.textContent = fmtFixed(result.airburst_km, 1);
          craterEl.textContent = '0';
          radiiEl.textContent = '0 / 0 / 0 / 0';
          thermalEl.textContent = '0';
          seismicEl.textContent = '0';
          tsunamiEl.textContent = 'None';
          popAffectedEl.textContent = '0';
          fatalitiesEl.textContent = '0';
          popNote.textContent = 'No population affected due to atmospheric disintegration.';
          viewer.scene.requestRender();
          return;
        }

        const marker = viewer.entities.add({
          position: Cesium.Cartesian3.fromDegrees(lng, lat, 1000),
          point: {
            pixelSize: 10,
            color: Cesium.Color.RED,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 2
          }
        });
        impactEntities.push(marker);

        const mildEllipse = createEllipse(lng, lat, result.mild_km, '#c8f7a6', 0.12, 'Mild');
        const moderateEllipse = createEllipse(lng, lat, result.moderate_km, '#ffd54a', 0.18, 'Moderate');
        const heavyEllipse = createEllipse(lng, lat, result.heavy_km, '#ff8a1f', 0.25, 'Heavy');
        const severeEllipse = createEllipse(lng, lat, result.severe_km, '#ff4444', 0.35, 'Severe');
        impactEntities.push(mildEllipse, moderateEllipse, heavyEllipse, severeEllipse);

        if (tsunamiRisk.risk !== 'None') {
          const tsunamiEllipse = createEllipse(lng, lat, Math.min(result.mild_km * 2, 100), '#1e90ff', 0.1, 'Tsunami');
          impactEntities.push(tsunamiEllipse);
        }

        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(lng, lat, 10000),
          orientation: {
            heading: Cesium.Math.toRadians(0),
            pitch: Cesium.Math.toRadians(-45),
            roll: 0
          },
          duration: 1,
          complete: () => {
            viewer.scene.requestRender();
          }
        });

        astDiaEl.textContent = fmtFixed(result.diameter_m, 1);
        keValEl.textContent = fmt(parseFloat(result.ke.toFixed(0)));
        keSciEl.textContent = fmtSci(result.ke);
        airburstEl.textContent = '0';
        craterEl.textContent = fmtFixed(result.crater_km, 2);
        radiiEl.textContent = `${fmtFixed(result.severe_km, 2)} / ${fmtFixed(result.heavy_km, 2)} / ${fmtFixed(result.moderate_km, 2)} / ${fmtFixed(result.mild_km, 2)}`;
        thermalEl.textContent = fmtFixed(result.thermal_km, 2);
        seismicEl.textContent = fmtFixed(result.seismic_mag, 1);
        tsunamiEl.textContent = `${tsunamiRisk.risk} (${tsunamiRisk.waveHeight} m waves)`;

        popNote.textContent = 'Estimating population — fetching country data...';
        try {
          const popEst = await estimatePopulationImpact(lat, lng, result);
          const totalAff = Math.round(popEst.totalAffected);
          const totalFatal = Math.round(popEst.totalFatal);
          popAffectedEl.textContent = totalAff.toLocaleString();
          fatalitiesEl.textContent = totalFatal.toLocaleString();
          if (popEst.densityData && popEst.densityData.name) {
            popNote.textContent = `Using country-average density for ${popEst.densityData.name} (${Math.round(popEst.densityData.density)} ppl/km²). This is a coarse estimate.`;
          } else {
            popNote.textContent = `Using fallback global-average density (${Math.round(popEst.density)} ppl/km²). For more accuracy, connect a gridded population dataset.`;
          }
          if (totalAff < 1) popAffectedEl.textContent = '<1';
          if (totalFatal < 1) fatalitiesEl.textContent = '<1';
        } catch (e) {
          popNote.textContent = 'Population estimation failed — showing no estimate.';
          console.warn('Population estimation error:', e);
        }
        viewer.scene.requestRender();
      }

      // --- Raycasting for Clicking Globe ---
      const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
      handler.setInputAction((click) => {
        const cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);
        if (cartesian) {
          const cartographic = Cesium.Cartographic.fromCartesian(cartesian);
          const lng = Cesium.Math.toDegrees(cartographic.longitude);
          const lat = Cesium.Math.toDegrees(cartographic.latitude);
          latR.value = Math.max(-90, Math.min(90, lat));
          lngR.value = Math.max(-180, Math.min(180, lng));
          updateDisplays();
          simulate(true);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      // --- Tooltip Handling ---
      let tooltipDiv = null;
      function showTooltip(event, content) {
        if (!tooltipDiv) {
          tooltipDiv = document.createElement('div');
          tooltipDiv.style.position = 'absolute';
          tooltipDiv.style.background = 'rgba(0,0,0,0.8)';
          tooltipDiv.style.color = '#fff';
          tooltipDiv.style.padding = '5px 10px';
          tooltipDiv.style.borderRadius = '5px';
          tooltipDiv.style.pointerEvents = 'none';
          tooltipDiv.style.zIndex = '1000';
          document.body.appendChild(tooltipDiv);
        }
        tooltipDiv.innerHTML = content;
        tooltipDiv.style.left = `${event.position.x + 10}px`;
        tooltipDiv.style.top = `${event.position.y + 10}px`;
        tooltipDiv.style.display = 'block';
      }

      function hideTooltip() {
        if (tooltipDiv) {
          tooltipDiv.style.display = 'none';
        }
      }

      handler.setInputAction((movement) => {
        const picked = viewer.scene.pick(movement.endPosition);
        if (picked && picked.id && picked.id.label) {
          showTooltip(movement, picked.id.label.text);
        } else {
          hideTooltip();
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

      // --- Animation: Falling Emoji ---
      const fallWrap = $('fallWrap');
      function animateFallTo(lat, lng, done) {
        const screenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(
          viewer.scene,
          Cesium.Cartesian3.fromDegrees(lng, lat)
        );
        if (!screenPos) {
          done && done();
          return;
        }

        const el = document.createElement('div');
        el.className = 'fall';
        el.innerHTML = '☄️';
        el.style.left = `${screenPos.x}px`;
        el.style.top = '-120px';
        el.style.opacity = '1';
        el.style.transition = 'top 900ms cubic-bezier(.2,.9,.2,1), opacity 200ms linear';
        fallWrap.appendChild(el);

        void el.offsetWidth;
        const clampY = Math.min(Math.max(screenPos.y, 20), fallWrap.clientHeight - 20);
        el.style.top = `${clampY}px`;

        const onEnd = (ev) => {
          if (ev.propertyName === 'top') {
            el.removeEventListener('transitionend', onEnd);
            el.style.transition = 'opacity 300ms linear';
            el.style.opacity = '0';
            setTimeout(() => {
              el.remove();
              done && done();
            }, 320);
          }
        };
        el.addEventListener('transitionend', onEnd);

        setTimeout(() => {
          if (document.body.contains(el)) {
            el.remove();
            done && done();
          }
        }, 1600);
      }

      // --- Simulation ---
      const debouncedSimulate = debounce((animate = false) => simulate(animate), 80);

      async function simulate(animate = false) {
        try {
          const mass = Number(massR.value);
          const speed = Number(speedR.value);
          const angle = Number(angleR.value);
          const density = Number(densityR.value);
          const lat = Number(latR.value);
          const lng = Number(lngR.value);
          const def = Number(defR.value);
          const frag = Number(fragR.value);

          const elevation = await fetchUSGSElevation(lat, lng);
          const seismicZoneFactor = await fetchUSGSSeismicZone(lat, lng);
          const tsunamiRisk = await estimateTsunamiRisk(lat, lng, elevation, computeKE(mass, speed));

          computeImpact(mass, speed, angle, density, def, seismicZoneFactor, (result) => {
            result.seismic_mag = result.disintegrates ? 0 : estimateSeismicMagnitude(result.ke, seismicZoneFactor);

            const megatons = result.ke / 4.184e15;
            if (result.disintegrates) {
              warnBox.style.display = 'block';
              warnText.textContent = `Meteor disintegrates in atmosphere at ~${fmtFixed(result.airburst_km, 1)} km altitude — no ground impact.`;
            } else if (megatons > 1000) {
              warnText.textContent = `Extreme energy: ~${Math.round(megatons).toLocaleString()} megatons — global catastrophic potential.`;
              warnBox.style.display = 'block';
            } else if (megatons > 10) {
              warnText.textContent = `Large impact: ~${Math.round(megatons).toLocaleString()} megatons — regional devastation.`;
              warnBox.style.display = 'block';
            } else {
              warnBox.style.display = 'none';
            }

            if (animate) {
              animateFallTo(lat, lng, () => drawImpact(lat, lng, result, elevation, tsunamiRisk));
            } else {
              drawImpact(lat, lng, result, elevation, tsunamiRisk);
            }
          });
        } catch (e) {
          console.error('Simulation error:', e);
          warnBox.style.display = 'block';
          warnText.textContent = 'Error during simulation — please check input values.';
        }
      }

      // --- NASA NEO API Integration ---
      const apiKey = '4gkxMlrvfAdWiMnr4vCVL7zwizhtX77QCPALiQrd';

      async function fetchNEOs() {
        const today = new Date().toISOString().split('T')[0];
        const url = `https://api.nasa.gov/neo/rest/v1/feed?start_date=${today}&api_key=${apiKey}`;
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error('NEO API fetch failed');
          const data = await res.json();
          const neos = [];
          for (let date in data.near_earth_objects) {
            data.near_earth_objects[date].forEach(neo => {
              if (neo.estimated_diameter && neo.close_approach_data && neo.close_approach_data[0]) {
                neos.push(neo);
              }
            });
          }
          const sel = $('neoSelect');
          sel.innerHTML = '<option value="">Select NEO</option>';
          neos.forEach(neo => {
            const opt = document.createElement('option');
            opt.value = JSON.stringify({
              name: neo.name,
              designation: neo.designation,
              dia_min: neo.estimated_diameter.meters.estimated_diameter_min,
              dia_max: neo.estimated_diameter.meters.estimated_diameter_max,
              vel: neo.close_approach_data[0].relative_velocity.kilometers_per_second,
              close_date: neo.close_approach_data[0].close_approach_date,
              miss_km: neo.close_approach_data[0].miss_distance.kilometers,
              density: 3000,
              semi_major_axis: neo.orbital_data?.semi_major_axis || 1.5, // AU, fallback
              eccentricity: neo.orbital_data?.eccentricity || 0.4 // Fallback
            });
            opt.textContent = `${neo.name} (Close Approach: ${neo.close_approach_data[0].close_approach_date})`;
            sel.appendChild(opt);
          });
          // Add Impactor-2025 preset
          const impactor2025 = {
            name: 'Impactor-2025',
            designation: '2025-IMP',
            dia_min: 180,
            dia_max: 220,
            vel: 25,
            close_date: '2025-10-05',
            miss_km: 10000,
            density: 3000,
            semi_major_axis: 1.2,
            eccentricity: 0.5
          };
          const opt = document.createElement('option');
          opt.value = JSON.stringify(impactor2025);
          opt.textContent = 'Impactor-2025 (Hypothetical, Oct 2025)';
          sel.appendChild(opt);
          if (neos.length === 0) {
            sel.innerHTML += '<option value="">No NEOs found in the next week</option>';
          }
        } catch (e) {
          console.error('NEO fetch error:', e);
          $('neoSelect').innerHTML = '<option value="">Error fetching NEOs</option>';
        }
      }

      // --- Orbital Mechanics and Trajectory ---
      function keplerToCartesian(a, e, trueAnomaly, mu = 1.327e20) { // mu = Sun's gravitational parameter
        const r = (a * (1 - e * e)) / (1 + e * Math.cos(trueAnomaly));
        const x = r * Math.cos(trueAnomaly);
        const y = r * Math.sin(trueAnomaly);
        return new Cesium.Cartesian3(x, y, 0);
      }

      async function plotTrajectory(designation, closeDate, missKm, semiMajorAxis, eccentricity, deltaV = 0) {
        if (trajectoryEntity) {
          viewer.entities.remove(trajectoryEntity);
          trajectoryEntity = null;
        }
        if (deflectedTrajectoryEntity) {
          viewer.entities.remove(deflectedTrajectoryEntity);
          deflectedTrajectoryEntity = null;
        }

        const start = new Date(closeDate);
        start.setDate(start.getDate() - 2);
        const stop = new Date(closeDate);
        stop.setDate(stop.getDate() + 2);
        const startStr = start.toISOString().split('T')[0];
        const stopStr = stop.toISOString().split('T')[0];

        // Try Keplerian orbit first
        const positions = [];
        const times = [];
        const distances = [];
        const steps = 48; // 1h steps over 2 days
        for (let i = 0; i <= steps; i++) {
          const trueAnomaly = (i / steps) * 2 * Math.PI;
          let pos = keplerToCartesian(semiMajorAxis * 1.496e11, eccentricity, trueAnomaly); // AU to meters
          if (deltaV) {
            const deflectedA = semiMajorAxis * (1 + deltaV / 1000); // Simplified deflection
            pos = keplerToCartesian(deflectedA * 1.496e11, eccentricity, trueAnomaly);
          }
          const time = Cesium.JulianDate.fromDate(new Date(start.getTime() + i * 3600 * 1000));
          times.push(time);
          positions.push(pos);
          distances.push(Cesium.Cartesian3.magnitude(pos) / 1000);
        }

        // Fallback to JPL Horizons if Keplerian fails
        if (positions.length === 0) {
          const url = `https://ssd.jpl.nasa.gov/api/horizons.api?format=json&COMMAND='DES=${encodeURIComponent(designation)};'&OBJ_DATA='NO'&MAKE_EPHEM='YES'&EPHEM_TYPE='VECTORS'&CENTER='500'&START_TIME='${startStr}'&STOP_TIME='${stopStr}'&STEP_SIZE='1h'&OUT_UNITS='KM-S'&REF_SYSTEM='J2000'&VEC_LABELS='NO'&VEC_DELTA='NO'&CSV_FORMAT='YES'&VEC_TABLE='3'`;
          try {
            const res = await fetch(url);
            if (!res.ok) throw new Error('Horizons API fetch failed');
            const data = await res.json();
            const text = data.result;
            const soeIndex = text.indexOf('$$SOE');
            const eoeIndex = text.indexOf('$$EOE');
            if (soeIndex === -1 || eoeIndex === -1) throw new Error('No ephemeris data found');
            const ephemText = text.substring(soeIndex + 5, eoeIndex).trim();
            const lines = ephemText.split('\n');
            for (let line of lines) {
              if (line.trim() === '') continue;
              const parts = line.split(',').map(s => s.trim());
              const jd = parseFloat(parts[0]);
              const x = parseFloat(parts[2]) * 1000;
              const y = parseFloat(parts[3]) * 1000;
              const z = parseFloat(parts[4]) * 1000;
              const time = Cesium.JulianDate.fromJd(jd, Cesium.TimeStandard.UTC);
              const inertialPos = new Cesium.Cartesian3(x, y, z);
              const pm = new Cesium.Matrix3();
              Cesium.Transforms.computeIcrfToFixedMatrix(time, pm);
              let fixedPos = pm ? Cesium.Matrix3.multiplyByVector(pm, inertialPos, new Cesium.Cartesian3()) : inertialPos;
              times.push(time);
              positions.push(fixedPos);
              distances.push(Cesium.Cartesian3.magnitude(fixedPos) / 1000);
            }
          } catch (e) {
            console.error('Trajectory fetch error:', e);
          }
        }

        if (positions.length === 0) {
          warnBox.style.display = 'block';
          warnText.textContent = 'Failed to fetch or plot asteroid trajectory.';
          return;
        }

        trajectoryEntity = viewer.entities.add({
          polyline: {
            positions: positions,
            width: 5,
            material: Cesium.Color.YELLOW.withAlpha(0.8),
            clampToGround: false
          }
        });

        if (deltaV) {
          const deflectedPositions = [];
          for (let i = 0; i <= steps; i++) {
            const trueAnomaly = (i / steps) * 2 * Math.PI;
            const deflectedA = semiMajorAxis * (1 + deltaV / 1000);
            const pos = keplerToCartesian(deflectedA * 1.496e11, eccentricity, trueAnomaly);
            deflectedPositions.push(pos);
          }
          deflectedTrajectoryEntity = viewer.entities.add({
            polyline: {
              positions: deflectedPositions,
              width: 3,
              material: Cesium.Color.GREEN.withAlpha(0.6),
              clampToGround: false
            }
          });
        }

        let minIndex = 0;
        let minDist = distances[0];
        for (let i = 1; i < distances.length; i++) {
          if (distances[i] < minDist) {
            minDist = distances[i];
            minIndex = i;
          }
        }
        const minPos = positions[minIndex];
        const carto = Cesium.Cartographic.fromCartesian(minPos);
        latR.value = Cesium.Math.toDegrees(carto.latitude);
        lngR.value = Cesium.Math.toDegrees(carto.longitude);
        updateDisplays();

        if (minDist < 6371 && !deltaV) {
          warnBox.style.display = 'block';
          warnText.textContent = `This NEO has a close approach distance of ~${fmtFixed(minDist, 1)} km — potential impactor!`;
        } else if (deltaV && minDist >= 6371) {
          warnBox.style.display = 'block';
          warnText.textContent = `Deflection successful! New miss distance: ~${fmtFixed(minDist, 1)} km.`;
        }
        viewer.flyTo(trajectoryEntity);
        viewer.scene.requestRender();
      }

      // --- Defend Earth Mode ---
      async function defendEarth() {
        const def = Number(defR.value);
        const d = JSON.parse($('neoSelect').value || '{}');
        if (!d.designation) {
          warnBox.style.display = 'block';
          warnText.textContent = 'Select an NEO to simulate deflection.';
          return;
        }
        await plotTrajectory(d.designation, d.close_date, d.miss_km, d.semi_major_axis, d.eccentricity, def);
        simulate(false);
        if (def > 0) {
          warnBox.style.display = 'block';
          warnText.textContent = `Deflection applied (Δv = ${def} m/s). Check green trajectory for new path!`;
        }
      }

      // --- Impactor-2025 Scenario ---
      async function loadImpactor2025() {
        const impactor2025 = {
          name: 'Impactor-2025',
          designation: '2025-IMP',
          dia_min: 180,
          dia_max: 220,
          vel: 25,
          close_date: '2025-10-05',
          miss_km: 10000,
          density: 3000,
          semi_major_axis: 1.2,
          eccentricity: 0.5
        };
        const avg_dia = (impactor2025.dia_min + impactor2025.dia_max) / 2;
        const radius = avg_dia / 2;
        const volume = (4 / 3) * Math.PI * Math.pow(radius, 3);
        const mass = impactor2025.density * volume;
        setRangeValue(massR, Math.min(Math.max(mass, 1e6), 1e13));
        setRangeValue(speedR, Math.min(Math.max(impactor2025.vel * 1000, 5000), 50000));
        setRangeValue(densityR, impactor2025.density);
        setRangeValue(angleR, 45);
        setRangeValue(defR, 0);
        setRangeValue(fragR, 0);
        setRangeValue(latR, 37.7749); // Example: San Francisco
        setRangeValue(lngR, -122.4194);
        await plotTrajectory(impactor2025.designation, impactor2025.close_date, impactor2025.miss_km, impactor2025.semi_major_axis, impactor2025.eccentricity);
        simulate(true);
      }

      // --- Events ---
      $('simulateBtn').addEventListener('click', () => simulate(false));
      $('resetBtn').addEventListener('click', () => clearImpact());
      $('animateBtn').addEventListener('click', () => simulate(true));
      $('defendBtn').addEventListener('click', defendEarth);
      $('impactor2025Btn').addEventListener('click', loadImpactor2025);
      [massR, speedR, angleR, densityR, latR, lngR, defR, fragR].forEach(el => el.addEventListener('input', () => debouncedSimulate(false)));
      simulate(false);

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') simulate(false);
        if (e.key === 'r') clearImpact();
        if (e.key === 'd') defendEarth();
      });

      $('fetchNeoBtn').addEventListener('click', fetchNEOs);
      $('neoSelect').addEventListener('change', async (e) => {
        if (!e.target.value) return;
        const d = JSON.parse(e.target.value);
        const avg_dia = (d.dia_min + d.dia_max) / 2;
        const radius = avg_dia / 2;
        const volume = (4 / 3) * Math.PI * Math.pow(radius, 3);
        const mass = d.density * volume;
        const clamped_mass = Math.min(Math.max(mass, 1e6), 1e13);
        setRangeValue(massR, clamped_mass);
        const speed = d.vel * 1000;
        const clamped_speed = Math.min(Math.max(speed, 5000), 50000);
        setRangeValue(speedR, clamped_speed);
        setRangeValue(densityR, d.density);
        setRangeValue(angleR, 45);
        setRangeValue(defR, 0);
        setRangeValue(fragR, 0);
        await plotTrajectory(d.designation, d.close_date, d.miss_km, d.semi_major_axis, d.eccentricity);
        simulate(false);
      });

      function setRangeValue(range, v) {
        range.value = v;
        updateDisplays();
        debouncedSimulate(false);
      }

      document.getElementById('ionToken').addEventListener('change', async () => {
        await initializeViewer();
        simulate(false);
      });
    });
  </script>
</body>
</html>
